window.docContents[25].resolve({"/Fundamentals/#Documentation-MRiscX--Fundamentals--Hoare-Logic--Hoare-Triples":{"contents":"A central element of Hoare-logic is the Hoare-triple. A Hoare-triple\nis a statement about the state of a machine before and after the execution\nof a command. By default, such a triple is noted as follows:\n\n\n\\{P\\} c \\{Q\\}\n\n\nP and Q are logical statements about the state before and after the\nexecution of the program segment c.\nWhat exactly these statements describe depends on the structure of the\nrespective machine state.\nFor example, they may refer to variable assignments, the contents of memory,\nregister values, or the value of the program counter.\nThe Hoare-triple now states:\n\nIf command c begins execution in a state that satisfies statement P,\nand if c eventually terminates in a state, then that final state satisfies\nstatement Q.\nThe statement P is called the  precondition of the\ntriple, and Q is the\n postcondition.\n\nExample:\n\n{x = 0} x := x + 1 {x = 1}\n\n\nThis Hoare-triple states:\nIf there is a state in which x=0 applies, and then the code x := x + 1\nis executed, then x = 1 applies afterwards.\n\n","context":"Documentation MRiscX\u0009Fundamentals\u0009Hoare-Logic","header":"2.2.1. Hoare-Triples","id":"/Fundamentals/#Documentation-MRiscX--Fundamentals--Hoare-Logic--Hoare-Triples"},"/Fundamentals/#availableInstructions":{"contents":"In the current version of MRiscX, not all RISC-V instructions are available.\nHere is a list of the instructions which are implemented yet:\n\nDefinition of the Instructions.Load an address into a registerSyntax:la x dst, mwhere (dst m : UInt64).Note: Numbers of type UInt64 can be written as hexadecimal\n(e.g. 0xf123), which might serve as address.Load an immediate value into a registerSyntax:li x dst, mwhere (dst m : UInt64).Copy the contents of an a register into another registerSyntax:mv x dst, x regwhere (dst reg : UInt64).Add an immediate value and a register, store the result into a registerSyntax:addi x dst, x reg, mwhere (dst reg m : UInt64).Increment the content of a register by oneSyntax:inc x dstwhere (dst : UInt64).Add the contents of two registers and store the value into a registerSyntax:add x dst, x reg1, x reg2where (dst reg1 reg2 : UInt64).Subtract an immediate value form a register, store the result into a\nthird registerSyntax:subi x dst, x reg, nwhere (dst reg n : UInt64).Decrement the content of a register by oneSyntax:dec x dstwhere (dst : UInt64).Subtract the value of a register form another register,\nstore the result into a third registerSyntax:sub x dst, x reg1, x reg2where (dst reg1 reg2 : UInt64).Bitwise-XOR operation between an immediate value and the content of a\nregister, store the result into a registerSyntax:xor x dst, x reg, nwhere (dst reg n : UInt64).Bitwise-XOR operation between the contents of two registers,\nstore the result into a third registerSyntax:xor x dst, x reg1, x reg2where (dst reg1 reg2 : UInt64).Load the content of the memory at the address which provided as an\nimmedtiate value into a registerSyntax:lw x dst, mem_addrwhere (dst mem_addr : UInt64).Load the content of the memory at the address which is stored in a register\ninto a registerSyntax:lw x dst, x reg_with_mem_addrwhere (dst reg_with_mem_addr : UInt64).Load the content of a register into the memory at the address which is\nstored in a registerSyntax:sw x reg_with_value, x reg_with_mem_addrwhere (reg_with_value reg_with_mem_addr : UInt64).Jump to a given labelname.Syntax:j labelwhere (label : ident).Note: Due to the elaboration, the actual syntax does not require a String\nbut an identifier (ident). Therefore, there is no need to use quotation\nmarks to represent a sequence of characters as a string type.\nThis is also true for all the following conditional jump instuctionsJump to a given labelname when the contents of two provided registers are\nequalSyntax:beq x reg1, x reg2, labelwhere (reg1 reg2 : UInt64) (label : ident).Jump to a given labelname when the contents of two provided registers are\nnot equalSyntax:bne x reg1, x reg2, labelwhere (reg1 reg2 : UInt64) (label : ident).Jump to a given labelname when the content of the first register provided\nis greater than the content of the other register provided.Syntax:bgt x reg1, x reg2, labelwhere (reg1 reg2 : UInt64) (label : ident).Jump to a given labelname when the content of the first register provided\nis less or equal the content of the other register provided.Syntax:ble x reg1, x reg2, labelwhere (reg1 reg2 : UInt64) (label : ident).Jump to a given labelname when the content of the register provided\nis equal to zero.Syntax:beqz x reg, labelwhere (reg : UInt64) (label : ident).Jump to a given labelname when the content of the first register provided\nis greater than the content of the other register provided.Syntax:bnez x reg, labelwhere (reg : UInt64) (label : ident).Default instruction, sets the terminated flag to true\n\n","context":"Documentation MRiscX\u0009Fundamentals\u0009The Assembly Language","header":"2.1.1. Available Instructions","id":"/Fundamentals/#availableInstructions"}});