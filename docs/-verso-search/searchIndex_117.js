window.docContents[117].resolve({"/Process-of-proving-the-formal-correctness/#Documentation-MRiscX--Process-of-proving-the-formal-correctness--General-Idea-In-Proof":{"contents":"The general idea of a proof of formal correctness of an implementation looks as like\nthis:\n\n1. Identify:1. Sequential code sections2. Conditional branches3. Loops2. Use the tactic S_SEQ (or the custom tactic sapply_s_seq) to isolate these sections.3. Now, there several situations that might come up:1. Sequential code sections* Use S_SEQ or some custom tactic to \"peel off\" the last instruction and inspect\n      it isolatedly. You might have to think of an fitting R.* Use the specification for the isolated instruction to formally verify the\n      correctness of this single step.* Repeat the process2. Conditional branches* Apply S_COND* Show, that Q is valid with1. P \\wedge C2. P \\wedge \\neg C\n      by going through both code sections and repeat from 1.3. Loops* Apply S_LOOP by finding the condition C of the loop, the loop invariant I\n      and the loop variant V as described in the introduction of\n      the Hoare-rules* Show the formal correctness of the loop body, when the C is true (the condition\n      for one loop iteration is given)* Show, that the loop is left when Â¬C (the condition for one loop iteration is not given)\n\nFor some easy examples, have a look into the\nExample file.\nThere you can find how the custom tactics are applied on some small code examples.\n\nAlso, a bigger example can be seen in the file\nOtpProof.\nHere, an implementation of the \"One-Time-Pad\" was formally verified.\nNote, that this example is quite old and should be refactored.\n\n\n","context":"Documentation MRiscX\u0009Process of proving the formal correctness","header":"4.2. General Idea In Proof","id":"/Process-of-proving-the-formal-correctness/#Documentation-MRiscX--Process-of-proving-the-formal-correctness--General-Idea-In-Proof"}});