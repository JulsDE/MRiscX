window.docContents[72].resolve({"/Limitations/#limitation":{"contents":"This DSL has some limitations, since it is still work in progress.\nAt the moment, it is a simple way to prove the formal correctness of simple,\nsequential code. It can also be used to formally verify the correctness of some\nmore complex code (see\nOtpProof\n), but unfortunately for those proofs it becomes very messy and you have to have a deep\nunderstanding of Lean itself, how the model MState is implemented and you need\nto be very familiar with the Hoare-logic.\n\nAlso, there are some features missing which are currently implemented or at least on the\nTODO list. This list looks like this:\n\n* Compilation of assembly instructions* As shown in the list of available instructions, several\n    instructions are missing. These will be implemented in future versions.* Incorporation of calling conventions* Currently, it is possible to modify the contents of register x_0. In RISC-V, however, this\n    register is hard-wired to zero and cannot be changed.* This restriction, along with additional RISC-V calling conventions, should be formally\n    integrated into MRiscX.* Multiple register names* Support for register aliases beyond x_n.* For example, registers such as t_n or a_n should be available.* Proof automation* At present, only the application of the rule S-SEQ is automated. This should be extended to\n    automate the application of additional Hoare rules.* Currently, the tactic apply_spec can be used to apply a specification. However, it still\n    requires manually providing details such as the current program counter location. This process\n    could be further automated, ideally to the point where even the name of the required\n    specification is inferred automatically.* We aim to support multiple levels of proof automation. For instance, users should be able to\n    apply tactics such as sapply_s_seq to follow the verification process step by step, or use\n    more advanced tactics like auto_seq - or even a single high-level tactic - that automatically\n    verifies all steps at once for fast and convenient formal verification of assembly code.\n\n\n","context":"Documentation MRiscX","header":"5. Limitations","id":"/Limitations/#limitation"},"/Writing-a-specification/#preAndPostcondition":{"contents":"First of all, we need to be aware what our program is actually doing.\nOnce this is clear, we want to express this in first-order predicate logic.\n\nLet's take a look at the following two examples:\n\n#check\n  mriscx\n    first:\n            li x 1, 1\n            li x 2, 43\n            add x 3, x 1, x 2\n\n    finish:\n  end\n\n\nwe expect after execution this program,\nthat the registers x_1 and x_2 hold the values\nwhich were loaded into them, the register x_3 holds the result of the\naddition of x_1 and x_2.\nThat means, the specification of this code snippet should look something like this:\nx_1 = 1 \\wedge x_2 = 43 \\wedge x_3 = x_1 + x_2\n\nThe next example involves a loop:\n\nvariable (regWithAddr addr counter regWithValue\n          length: UInt64)\n#check\n  mriscx\n    first:\n            la x regWithAddr, addr\n            li x counter, length\n\n    loop:\n            beqz x counter, finish\n            sw x regWithValue, x addr\n            addi x addr, x addr, 1\n            subi x counter, x counter, 1\n            j loop\n\n    finish:\n  end\n\n\n\nIn this code, we have no concrete values, but some variables. This makes\nthe specification more general and we do not restrict the specification on\ncertain values.\nSo let's see what is happening here:\n\nFirst, an address addr is loaded into a register regWithAddr.\nThen, the loop is entered. It starts with a conditional jump, which happens when\nthe content of a register counter equals zero. If that is the case, we jump to the label\nfinish.\nWhen the register holds a value greater than zero, the actual loop body is entered.\nThe content of a register regWithValue is stored into the memory at the address the\nregister regWithAddr holds.\nOnce this is done, the address inside the register regWithAddr is incremented by one,\nthe value the register counter holds is decremented by one and we jump back to the\nlabel loop.\n\nFurthermore, let \\text{memory}(n) denote the memory address n.\nThen, the specification of this program could be formulated as follows:\n\n\n\\begin{aligned}\n\\text{Pre} \\; \\coloneqq \\;\n& i < \\text{length}\n  \\;\\wedge\\;\n  \\text{addr} + \\text{length} - 1 < 2^{64} \\\\[0.5em]\n\\forall i \\in \\mathbb{U}_{64},\\;\n& \\text{Pre}\n  \\;\\rightarrow\\;\n  \\text{memory}(\\text{addr} + i)\n  = x_{\\text{regWithValue}}\n\\end{aligned}\n\n\nSo as you can see, we need multiple things to successfully write down a\ncorrect specification:\n\n1. First order logic with arithmetic expressions2. Access to the values (registers, memory, ...) of a certain machine state\n\nThe point 1. is already provided by lean itself, so just need to somehow\naccess a machine state.\nMRiscX offers a simple way to do this.\n\nInside the ⦃⦄ braces, we can write down first order logic formulas just like\nin usual terms of type Prop. Additionally, there are the following custom term,\nwhich can be used:\n\n* ⸨terminated⸩This term is the MState.terminated flag.\n  It indicates whether the program has terminated and whether the current machine state is legal.\n  If this flag is true, the machine state is no longer legal, and no further instructions\n  can be executed.\n  Consequently, ⦃¬⸨terminated⸩⦄ serves as a precondition that is almost always\n  required to ensure that instructions can be executed and, ultimately, to establish the\n  functional correctness of a program.* ⸨pc⸩With this term, we can define the value of the MState.pc. Using this, we can\n  ensure that the MState.pc holds a certain value before or after\n  executing a program. Note, that l also ensures, that the MState.pc points to\n  a certain line before executing the program, so this term is often only useful in the\n  postcondition.* x[n], where n is either a number of type UInt64 or an identifier\n  (Lean.Parser.ident)Using this term we are able to define a value n for a register x_n in\n  MState.registers.\n  As already mentioned, this n can either be a number of type UInt64 or\n  an identifier.\n  This means, that the termsvariable (n v : UInt64)\n#check ⦃x[n] = v⦄\n#check ⦃x[1] = 42⦄\n#check ⦃x[1] = 0x4411⦄\nare all legal.\n  Also note, that lean inherently supports hexadecimal numbers, so ⦃x[1] = 0x4411⦄ is legal\n  and can be used to describe that a certain register holds a memory address.* mem[t], where t is a Lean.Term. This includes every custom term presented here.This term can be used to define a value of a certain place in the MState.memory.\n  Since it is possible to use the regular terms of lean as well as the custom terms,\n  we can load an address into a register, manipulate it and then use this register inside\n  the square brackets.#check ⦃mem[0x7ffe5367e044] = 4123⦄\n#check ⦃mem[x[2] + 1] = x[4] + x[5]⦄\n* labels[i], where i is of type Lean.Ident.Using this, we can ensure either that the label i exists on a specific line or that it does not\n  exist at all. Note, that the labels inside the code sections are already stored inside the\n  Code.labels, so they do not nee to be specified within the pre- or postcondition.This term returns an Option UInt64.#check ⦃labels[first] = some 0⦄\n#check ⦃labels[_L_store] = none⦄\n\n\nTo wrap things up, here is an example of a Hoare-triple with most of the terms presented:\n\n#check\n    mriscx\n      _start:\n              la x 2, 0x7ffe5367e044\n              addi x 2, x 2, 1\n              xori x 3, x 4, 412\n              sw x 3, x 2\n    end\n    ⦃¬⸨terminated⸩⦄\n    \"_start\" ↦ ⟨{\"_start\" + 4} | {n | n > \"_start\" + 4} ∪ {\"_start\"}⟩\n    ⦃x[3] = x[4] ^^^ 412 ∧ mem[x[2] + 1] = x[3]⦄\n\n\n","context":"Documentation MRiscX\u0009Writing a specification","header":"3.1. Pre- And Postcondition","id":"/Writing-a-specification/#preAndPostcondition"}});