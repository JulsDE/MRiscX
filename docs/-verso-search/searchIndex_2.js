window.docContents[2].resolve({"/Fundamentals/#l_as":{"contents":"The “original” Hoare-logic cannot be applied without restriction to all programs\nand architectures. In structured programming, there are no restrictions on the\napplication of Hoare-logic, as the sequence of commands is precisely defined.\nIt is always clearly defined which command\nwill be executed next, and there is no possibility of jumping to any arbitrary\ncommand. A sequential chain is formed in which each link must be executed one\nafter the other. This is not the case in unstructured programming\n\nUnstructured Programming := Programming, that uses goto.\nJump commands such as goto can be used to jump to any point in\nthe code.\nDue to these restrictions on control flow and the limited ability\nto reason about intermediate program points - which is required to support complete\ncorrectness - the “classical” Hoare-triples are unsuitable for unstructured programs\n.\nSince MRiscX contains elements of unstructured programming,\nan extended form of Hoare-logic is used, as presented by .\n\nIn the following, the functions MState.runOneStep is a function, which executes a\nsingle instruction and therefore transforms a machine state s into a machine state s'.\nThe function MState.runNSteps is the n-th iteration of MState.runOneStep.\nMState.pc represents the value the ProgramCounter points to in a machine state\ns.\nThese two functions substitute the functions nxt and lbl in the\n in the paper .\nWith those functions, the weak transition relation in MRiscX is defined as follows:\n\nnamespace myNameSpace\ndef weak (s s' : MState) (L_w L_b : Set UInt64)\n    (c : Code) : Prop :=\n  s.code = c →\n  ∃ (n:Nat), n > 0 ∧ s.runNSteps n = s' ∧ (s'.pc) ∈ L_w ∧\n  ∀ (n':Nat), 0 < n' ∧ n' < n →\n  (s.runNSteps n').pc ∉ (L_w ∪ L_b)\n\n\nThis weak relation, inspired by Lundberg et al. (2020),\nis defined over two MStates, s and s'.\nUnlike earlier formulations that take a single set of lines L,\nthis relation is parameterized by two sets of lines, L_w and L_b.This design has the advantage that the condition s'.pc ∈ L_w is already guaranteed\nby the relation itself. Since we assume L_w ∩ L_b = ∅, it immediately follows that\ns'.pc ∉ L_b must also hold. Consequently, the explicit postcondition s'.pc ∈ L_b in\nthe Judgment of L_as could be omitted. However, this simplification has not yet been\napplied in the current version.This relation is defined as follows:State s' is reached from state s after exactly n steps, where n > 0, and the program\ncounter of s' points to a line in L_w. Moreover, there exists no n' ∈ ℕ with 0 < n' < n\nsuch that the state reached after n' steps from s has its program counter in L_w ∪ L_b.\nIn other words, s' is the first state along the execution path whose program counter lies\nin L_w.The weak relation is deterministic and partial: a program starting in s may never reach a\nstate whose program counter lies in L_w. Additionally, the relation guarantees that no\nintermediate state between s and s' has a program counter in L_w.With the help of this relation, unambiguous statements can be made about the flow of the program.\n\nThe weak transition relation has two machine states,\ns and s', and two sets of lines, L_W and L_B, as arguments.\nThis relation now states the following:\n\nIf n steps are taken from state s, state s' is reached.\nThe PC of s' points to a line that is an element of L_W.\nn must be greater than 0.\nFurthermore, there is no number n' with 0 < n' < n\nsuch that after n' steps from state s, state s' is reached, whose PC also points to a\nline in L_W \\cup L_B .\nThe weak transition relation is deterministic and partial,\nsince a program that starts in s may never reach L_W.\nIt also guarantees that no intermediate state  s'' \"between\" s and s' exists with\ns''.pc \\in L_W \\cup L_B.\n\nWith the help of this relation, unambiguous statements can be made about the flow of the program.\n\nIn order to formulate a Hoare-triple, the function hoare_triple_up can be used.\nThis function is inspired by the\n\\text{judgment of } \\mathcal{L}_\\text{{AS}} in \n\nThis hoare_triple_up function is defined as follows:\n\ndef hoare_triple_up (P Q : Assertion) (l : UInt64)\n    (L_w L_b : Set UInt64) (c : Code) :=\n  L_w ∩ L_b = ∅ →\n  L_w ≠ ∅ →\n  ∀ (s : MState), s.code = c →\n  s.pc = l →\n  P s →\n  ∃ (s' : MState),\n  (weak s s' L_w L_b c) ∧ Q s' ∧ s'.pc ∉ L_b\n\nend myNameSpace\n\n\nInspired by the judgement of L_{as} in the paper Lundberg et al. (2020).Suppose, that L_w ∩ L_b = ∅ and L_w ≠ ∅ hold, then the hoare_triple_up means:For all states s in which both P(s) and I(s) are satisfied and whose\nprogram counter points to l,\nthere exists a successor state s' for which both the relation\nweak(s, L_w ∪ L_b, s') and Q(s'), I(s') and s'.pc ∉ L_w\nare satisfied.\n\nThe notation introduced for a Hoare-triple looks like this:\n\nexample (P Q : Prop) (l : UInt64) (L_w L_b : Set UInt64)\n    (mriscx_code : Code):\n  mriscx_code\n  ⦃P⦄ l ↦ ⟨L_w | L_b⟩ ⦃Q⦄\n  := by sorry\n\n\n, where P and Q represent the pre- and postcondition\n\n\n\n\n\n","context":"Documentation MRiscX\u0009Fundamentals","header":"2.3. Extension Of The Hoare-Logic  <missing>","id":"/Fundamentals/#l_as"}});