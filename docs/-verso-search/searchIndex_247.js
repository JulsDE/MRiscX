window.docContents[247].resolve({"/Introduction/#Documentation-MRiscX--Introduction--First-Example":{"contents":"Now we have seen how the general structure of a Hoare-triple in MRiscX looks like,\nlet's look at a more fleshed-out example:\n\nexample:\n    mriscx\n      first:  li x 0, 2\n              li x 1, 0\n              la x 2, 0x123\n    end\n    ⦃¬⸨terminated⸩⦄\n    \"first\" ↦ ⟨{\"first\" + 3} |\n                  ({n:UInt64 | n = \"first\"}\n                  ∪ {n:UInt64 | n > \"first\" + 3})⟩\n    ⦃(x[0] = 2 ∧ x[1] = 0 ∧ x[2] = 0x123) ∧ ¬⸨terminated⸩⦄\n  := by sorry\n\n\nThe notation for defining the specification in a Hoare-triples\nwill be presented in depth in chapter .\nFor now, it should be enough to know, that ¬⸨terminated⸩ ensures that the\nprogram did not terminate yet and the machine state is in a legal state and x[n] represents\nthe register x_n.\n\nTo describe the example code above in words:\n\nLet  be the finite set of all natural numbers from 0 to 2^{64} - 1.\n\nAssume, that a given machine state is in a legal state.\nWhen we now run the given assembly code, starting at the label \"first\"\nand executing it until the PC points to the line \"first\" + 3, considering the\nrestriction that we do not visit any of the lines\n(\\{n \\in UInt64 \\mid n = \\text{\"first\"}\\} \\cup \\{n \\in UInt64 \\mid n \\gt \\text{\"first\"} + 3\\}),\nwe know that register x_0 holds the value 2, register x_1 holds the value 0, and\nregister x_3 holds the address 0x123.\n\nFurthermore, we know that the state is still valid and that the program\ncould execute additional instructions afterwards.\n\nIn the next chapter, we will have a look on the theoretical fundamentals MRiscX is built upon.\n\n\n","context":"Documentation MRiscX\u0009Introduction","header":"1.3. First Example","id":"/Introduction/#Documentation-MRiscX--Introduction--First-Example"}});